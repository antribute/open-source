export type PermifyIndexTemplate = Record<string, never>;
export const permifyIndexTemplate = `//
// Autogenerated by \`@antribute/backend\`
// Any modifications will be overwritten on subsequent runs.
//

import permify from '@permify/permify-node';
import { readFile } from 'fs/promises';

export interface PermissionsParams {
  objectId: string;
  objectType: string;
  relation: string;
  tenantId: string;
  userId: string;
  userType?: string;
}

export const buildPermify = () => {
  const client = permify.grpc.newClient({
    cert: null,
    endpoint: process.env.PERMIFY_ENDPOINT!,
  });
  return client;
};

export const writeSchema = async (tenantName: string, schemaPath: string) => {
  const permify = buildPermify();
  const schemaContent = (await readFile(schemaPath)).toString();
  await permify.schema.write({
    tenantId: tenantName,
    schema: schemaContent,
  });
};

export const createTenant = async (tenantName: string, schemaPath?: string) => {
  const permify = buildPermify();
  await permify.tenancy.create({
    id: tenantName,
    name: tenantName,
  });
  if (schemaPath) {
    await writeSchema(tenantName, schemaPath);
  }
};

interface AddPermissionsPerm extends Omit<PermissionsParams, 'tenantId'> {
  userRelation?: string
}

export const addPermissions = async (
  perms: AddPermissionsPerm[],
  tenantId: string
): Promise<void> => {
  const permify = buildPermify();
  await permify.relationship.write({
    metadata: {},
    tenantId,
    tuples: perms.map(({ objectId, objectType, relation, userId, userRelation, userType }) => ({
      entity: {
        id: objectId,
        type: objectType,
      },
      relation,
      subject: {
        id: userId,
        type: userType || 'user',
        relation: userRelation
      },
    })),
  });
};

export const checkPermission = async ({
  objectId,
  objectType,
  relation,
  tenantId,
  userId,
  userType,
}: PermissionsParams): Promise<boolean> => {
  const permify = buildPermify();
  const res = await permify.permission.check({
    metadata: {},
    tenantId,
    entity: {
      id: objectId,
      type: objectType,
    },
    permission: relation,
    subject: {
      id: userId,
      type: userType || 'user',
    },
  });
  return res.can === 1;
};

export const getAllObjectsWithPermission = async ({
  objectType,
  relation,
  tenantId,
  userId,
  userType,
}: Omit<PermissionsParams, 'objectId'>) => {
  const permify = buildPermify();
  const res = await permify.permission.lookupEntity({
    metadata: {},
    tenantId,
    entityType: objectType,
    permission: relation,
    subject: { id: userId, type: userType || 'user' },
  });
  return res.entityIds;
};

export const removePermission = async ({
  objectId,
  objectType,
  relation,
  tenantId,
  userId,
  userType,
}: PermissionsParams): Promise<void> => {
  const permify = buildPermify();
  await permify.relationship.delete({
    tenantId,
    filter: {
      entity: {
        ids: [objectId],
        type: objectType,
      },
      relation,
      subject: {
        ids: [userId],
        type: userType,
      },
    },
  });
};
`;
