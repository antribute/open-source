import { execa } from 'execa';
import { appendFile, mkdir, writeFile } from 'fs/promises';
import { resolve } from 'path';
import rimraf from 'rimraf';
import { fileURLToPath } from 'url';

import type { Config } from 'utils/config';
import logger from 'utils/logger';

const dirname = fileURLToPath(new URL('.', import.meta.url));

export const generatePrismaConfig = async (config: Config) => {
  logger.debug('Computing directories for Prisma schema generating', config);
  const { capabilities, prismaDir, serverDir } = config;
  const prismaBin = resolve(dirname, '..', 'node_modules', '.bin', 'prisma');
  logger.debug(`Prisma script path set to ${prismaBin}`, config);
  const prismaImportBin = resolve(dirname, '..', 'node_modules', '.bin', 'prisma-import');
  logger.debug(`Prisma Import script path set to ${prismaImportBin}`, config);
  // This glob here tries its best to avoid generated/schema.prisma. We may need to refactor this
  // later to account for someone naming one of their modules "schema"
  const allSchemasGlob = resolve(process.cwd(), serverDir, '**', '!(schema).prisma');
  logger.debug(`Schema search glob set to ${allSchemasGlob}`, config);
  const generatedPrismaSchemaPath = resolve(process.cwd(), prismaDir, 'generatedSchema.prisma');
  logger.debug(`Schema output file set to ${generatedPrismaSchemaPath}`, config);

  logger.debug('Deleting current prisma schema if exists', config);
  await rimraf(generatedPrismaSchemaPath);

  // Execute prisma-import and build our schema
  logger.debug('Executing prisma-import to build schema', config);
  await execa(prismaImportBin, [
    '--schemas',
    allSchemasGlob,
    '--output',
    generatedPrismaSchemaPath,
    '--force',
  ]);

  // Append the generator content to the newly built schema
  // TODO: Should we add the ability to use something besides postgres? Also should we allow custom
  // env vars for the db url? Or maybe we should just make that part of the config?
  const additionalSchemaContent = `
//
// Autogenerated by \`@antribute/backend-cli\`
// Any modifications will be overwritten on subsequent runs.
//

generator client {
  output   = "${resolve(process.cwd(), serverDir, 'generated', 'prisma')}"
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

${
  capabilities.graphql
    ? `generator pothos {
  clientOutput = "${resolve(process.cwd(), serverDir, 'generated', 'prisma')}"
  output       = "${resolve(process.cwd(), serverDir, 'generated', 'pothos', 'index.ts')}"
  provider     = "prisma-pothos-types"
}
`
    : ''
}`;

  const dbAccessorOutput = `//
// Autogenerated by \`@antribute/backend-cli\`
// Any modifications will be overwritten on subsequent runs.
//

import { PrismaClient } from '../prisma';

const globalForPrisma = global as unknown as { prisma: PrismaClient };

export const prisma =
  globalForPrisma.prisma ||
  new PrismaClient({
    log: ['query'],
  });

if (process.env.NODE_ENV !== 'production') {
  globalForPrisma.prisma = prisma;
}
`;

  const dbAccessorDir = resolve(process.cwd(), config.serverDir, 'generated', 'db');
  logger.debug(
    `Creating db accessor directory (if it doesn't already exist) at ${dbAccessorDir}`,
    config
  );
  await mkdir(dbAccessorDir, { recursive: true });
  const dbAccessorFile = resolve(dbAccessorDir, 'index.ts');
  logger.debug(`Writing db accessor to ${dbAccessorFile}`, config);
  await writeFile(dbAccessorFile, dbAccessorOutput);

  logger.debug('Appending Antribute content to generated schema', config);
  await appendFile(generatedPrismaSchemaPath, additionalSchemaContent);
  logger.info('Prisma Schema Successfully Updated', config);

  logger.debug('Running Prisma generate', config);
  await execa(prismaBin, ['generate', '--schema', generatedPrismaSchemaPath]);
  logger.info('Prisma Successfully Regenerated', config);
};

export const generateOrmConfig = async (config: Config) => {
  if (!config.capabilities.orm) {
    logger.info('ORM capability set to false, skipping generation', config);
    return;
  }
  switch (config.orm) {
    case 'none':
      logger.info('ORM set to "none", skipping generation', config);
      break;
    case 'prisma':
      logger.debug('Selected ORM: Prisma', config);
      await generatePrismaConfig(config);
      break;
    default:
      // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
      throw new Error(`Invalid ORM type ${config.orm}`);
  }
};
