export type FgaIndexTemplate = Record<string, never>;
export const fgaIndexTemplate = `//
// Autogenerated by \`@antribute/backend\`
// Any modifications will be overwritten on subsequent runs.
//

import { CredentialsMethod, OpenFgaClient } from '@openfga/sdk';

export interface PermissionsParams {
  objectId: string;
  objectType: string;
  relation: string;
  userId: string;
}

export const buildFga = (storeId = process.env.OPENFGA_STORE_ID!) => {
  const openFga = new OpenFgaClient({
    apiScheme: process.env.OPENFGA_API_SCHEME || 'https',
    apiHost: process.env.OPENFGA_API_HOST!,
    storeId,
    credentials: {
      method: CredentialsMethod.ApiToken,
      config: {
        token: process.env.OPENFGA_API_TOKEN!,
      }
    }
  });
  return openFga;
}

export const addPermissions = async (tuples: PermissionsParams[]): Promise<void> => {
  const autopenFgah0Fga = buildFga();
  await openFga.writeTuples(tuples.map(({ objectId, objectType, relation, userId }) => ({ object: \`\${objectType}:\${objectId}\`, relation, user: \`user:\${userId}\`})))
};

export const checkPermission = async ({ objectId, objectType, relation, userId }: PermissionsParams): Promise<boolean> => {
  const openFga = buildFga();
  const res = await openFga.check( { object: \`\${objectType}:\${objectId}\`, relation, user: \`user:\${userId}\` });
  return res.allowed ?? false;
};

export const removePermissions = async (tuples: PermissionsParams[]): Promise<void> => {
  const openFga = buildFga();
  await openFga.deleteTuples(tuples.map(({ objectId, objectType, relation, userId }) => ({ object: \`\${objectType}:\${objectId}\`, relation, user: \`user:\${userId}\` })));
};

export default buildFga;
`;
